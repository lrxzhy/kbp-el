deepdive {

  db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
  }

  calibration.holdout_fraction: 0.5

  ###
  ### VARIABLES
  ###

  schema.variables {

    el_candidate_link.is_correct: Boolean
    
    el_candidate_link_2.is_correct: Boolean

    relation_mentions.is_correct: Boolean

    relation_instances.is_correct: Boolean

  }


  ###
  ### EXTRACTORS
  ###

  extraction.extractors {

    # Clean output tables of all extractors.
    ext_cleanup {
      sql: """
        DELETE FROM relation_mentions;
        DELETE FROM relation_mention_features;
        DELETE FROM mentions;
        DELETE FROM mention_feature_text_num_words;
      """
      style: "sql_extractor"
    }

    #
    # Entity mentions
    #

    # Extract entity mentions from the sentences.
    ext_mention {
      input : """
        SELECT doc_id,
               sentence_id,
               my_array_to_string(words, '~^~', 'NULL') AS words,
               my_array_to_string(ner, '~^~', 'NULL') AS ner,
               my_array_to_string(character_offset_begin, '~^~', 'NULL') AS character_offset_begin,
               my_array_to_string(character_offset_end, '~^~', 'NULL') AS character_offset_end
        FROM sentence
      """
      output_relation: "mentions"
      udf: ${APP_HOME}"/udf/ext_mention.py"
      style: "tsv_extractor"
      dependencies : ["ext_cleanup"]
    }

    # # Useful for debugging the entity mention extractor.
    # # Produes a TSV file with the input query materialized; to debug the extractor simply run
    # # cat <file> | python <entity_mention_extractor> to see its output.
    # ext_mention_debug {
    #   input : """
    #     SELECT doc_id,
    #            sentence_id,
    #            my_array_to_string(words, '~^~', 'NULL') AS words,
    #            my_array_to_string(ner, '~^~', 'NULL') AS ner,
    #            my_array_to_string(character_offset_begin, '~^~', 'NULL') AS character_offset_begin,
    #            my_array_to_string(character_offset_end, '~^~', 'NULL') AS character_offset_end
    #     FROM sentence LIMIT 100
    #   """
    #   output_relation: "mentions"
    #   udf: ${APP_HOME}"/udf/util/dummy_extractor.py "${APP_HOME}"/udf/sample_data/ext_mention_sample_data.tsv"
    #   style: "tsv_extractor"
    #   dependencies : ["ext_cleanup"]
    # }

    #
    # Relation mention feature extractors.
    #
    # Extract features from relation mentions; relation mentions are pairs of entity mentions that
    # appear in the same sentence  The input query creates several lists of mention attributes
    # (mention_id, types, etc.) for each sentence, so the input to the extractor is a list of all
    # the mentions in a given sentence. The extractor then does an n^2 loop over these mentions to
    # get all potential mention pairs.    

    # Extract the feature which is the word sequence between the 2 mentions.
    ext_relation_mention_feature_wordseq {
      input: """
        SELECT s.doc_id AS doc_id,
               s.sentence_id AS sentence_id,
               array_to_string(max(s.lemma), '~^~') AS lemma,
               array_to_string(max(s.words), '~^~') AS words,
               array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
               array_to_string(array_accum(m.word), '~^~') AS mention_words,
               array_to_string(array_accum(m.type), '~^~') AS types,
               array_to_string(array_accum(m.start_pos), '~^~') AS starts,
               array_to_string(array_accum(m.end_pos), '~^~') AS ends
        FROM sentence s,
             mentions m
        WHERE s.doc_id = m.doc_id AND
              s.sentence_id = m.sentence_id
        GROUP BY s.doc_id,
                 s.sentence_id
        """
      output_relation: "relation_mention_features"
      udf: ${APP_HOME}"/udf/ext_relation_mention_features_wordseq.py"
      style: "tsv_extractor"
      dependencies: ["ext_cleanup", "ext_mention"]
    }

    # # Useful for debugging the relation mention word sequence feature extractor.
    # # Produes a TSV file with the input query materialized; to debug the extractor simply run
    # # cat <file> | python <relation_mention_wordseq_extractor> to see its output.
    # ext_relation_mention_feature_wordseq_debug {
    #   input: """
    #     SELECT s.doc_id AS doc_id,
    #            s.sentence_id AS sentence_id,
    #            array_to_string(max(s.lemma), '~^~') AS lemma,
    #            array_to_string(max(s.words), '~^~') AS words,
    #            array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
    #            array_to_string(array_accum(m.word), '~^~') AS mention_words,
    #            array_to_string(array_accum(m.type), '~^~') AS types,
    #            array_to_string(array_accum(m.start_pos), '~^~') AS starts,
    #            array_to_string(array_accum(m.end_pos), '~^~') AS ends
    #     FROM sentence s,
    #          mentions m
    #     WHERE s.doc_id = m.doc_id AND
    #           s.sentence_id = m.sentence_id
    #     GROUP BY s.doc_id,
    #              s.sentence_id
    #     """
    #   output_relation: "relation_mention_features"
    #   udf: ${APP_HOME}"/udf/util/dummy_extractor.py "${APP_HOME}"/udf/sample_data/ext_relation_mention_wordseq_sample_data.tsv"
    #   style: "tsv_extractor"
    #   dependencies: ["ext_cleanup", "ext_mention"]
    # }

    # Extract the dependency path between the 2 mentions.
    ext_relation_mention_feature_deppath {
      input: """
        SELECT s.doc_id AS doc_id,
               s.sentence_id AS sentence_id,
               array_to_string(max(s.lemma), '~^~') AS lemma,
               replace(array_to_string(max(s.dep_graph), '~^~'), E'\t', ' ') AS dep_graph,
               array_to_string(max(s.words), '~^~') AS words,
               array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
               array_to_string(array_accum(m.word), '~^~') AS mention_words,
               array_to_string(array_accum(m.type), '~^~') AS types,
               array_to_string(array_accum(m.start_pos), '~^~') AS starts,
               array_to_string(array_accum(m.end_pos), '~^~') AS ends
        FROM sentence s,
             mentions m
        WHERE s.doc_id = m.doc_id AND
              s.sentence_id = m.sentence_id
        GROUP BY s.doc_id,
                 s.sentence_id
        """
      output_relation: "relation_mention_features"
      udf: ${APP_HOME}"/udf/ext_relation_mention_features_deppath.py"
      style: "tsv_extractor"
      dependencies: ["ext_cleanup", "ext_mention"]
    }

    # # Useful for debugging the relation mention dependency path feature extractor.
    # # Produes a TSV file with the input query materialized; to debug the extractor simply run
    # # cat <file> | python <relation_mention_deppath_extractor> to see its output.
    # ext_relation_mention_feature_deppath_debug {
    #   input: """
    #     SELECT s.doc_id AS doc_id,
    #            s.sentence_id AS sentence_id,
    #            array_to_string(max(s.lemma), '~^~') AS lemma,
    #            replace(array_to_string(max(s.dep_graph), '~^~'), E'\t', ' ') AS dep_graph,
    #            array_to_string(max(s.words), '~^~') AS words,
    #            array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
    #            array_to_string(array_accum(m.word), '~^~') AS mention_words,
    #            array_to_string(array_accum(m.type), '~^~') AS types,
    #            array_to_string(array_accum(m.start_pos), '~^~') AS starts,
    #            array_to_string(array_accum(m.end_pos), '~^~') AS ends
    #     FROM sentence s,
    #          mentions m
    #     WHERE s.doc_id = m.doc_id AND
    #           s.sentence_id = m.sentence_id
    #     GROUP BY s.doc_id,
    #              s.sentence_id
    #     """
    #   output_relation: "relation_mention_features"
    #   udf: ${APP_HOME}"/udf/util/dummy_extractor.py "${APP_HOME}"/udf/sample_data/ext_relation_mention_deppath_sample_data.tsv"
    #   style: "tsv_extractor"
    #   dependencies: ["ext_cleanup", "ext_mention"]
    # }



    ### FEATURES FOR MENTIONS

    # The number of words in the mention text.
    mention_text_num_words {
      input: """
          SELECT doc_id,
                 mention_id,
                 word
            FROM mentions
        """
      output_relation: "mention_feature_text_num_words"
      udf: ${APP_HOME}"/udf/mention_features/mention_text_num_words.py"
      style: "tsv_extractor"
      dependencies: ["ext_mention"]
    }

    # # Useful for debugging the entity mention feature extractor.
    # # Produes a TSV file with the input query materialized; to debug the extractor simply run
    # # cat <file> | python <entity_mention_feature_extractor> to see its output.
    # mention_text_num_words_debug {
    #   input: """
    #       SELECT doc_id,
    #              mention_id,
    #              word
    #         FROM mentions
    #         WHERE mention_id='AFP_ENG_20070405.0102.LDC2009T13_497_505' or
    #               mention_id='AFP_ENG_20070405.0102.LDC2009T13_515_519' or
    #               mention_id='AFP_ENG_20070405.0102.LDC2009T13_522_555'
    #     """
    #   output_relation: "mention_feature_text_num_words"
    #   udf: ${APP_HOME}"/udf/util/dummy_extractor.py "${APP_HOME}"/udf/sample_data/ext_mention_feature_sample_data.tsv"
    #   style: "tsv_extractor"
    #   dependencies: ["ext_mention"]
    # }



    #########    
    ## ENTITY LINKING
    #########

    ### ENTITY LINKING EXTRACTORS (1 for each rule)

    ### ROUND 1 OF FEATURES

    # Rule 1: everything is NIL by default (get all the mentions, and link them to the NIL entity)
    everything_nil {
      sql: """
          DROP TABLE IF EXISTS el_everything_nil CASCADE;

          CREATE TABLE el_everything_nil AS
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e"
              WHERE e.fid = 'NIL0000';
        """
      style: "sql_extractor"
      dependencies: ["ext_mention"]
    }

    # Rule 2: exact string matching
    exact_str_match {
      sql: """
          DROP TABLE IF EXISTS el_exact_str_match CASCADE;

          CREATE TABLE el_exact_str_match AS
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e"
              WHERE e.text = m.word;
        """
      style: "sql_extractor"
      dependencies: ["ext_mention"]
    }

    # Rule 3: Wikipedia link (does the entity have a Wiki link with the same text as the mention?)
    wiki_link {
      sql: """
          DROP TABLE IF EXISTS el_wiki_link CASCADE;

          CREATE TABLE el_wiki_link AS
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   entity_feature_wikilink AS "w"
              WHERE e.fid = w.eid1 AND
                    m.word = w.featurevalue3;
        """
      style: "sql_extractor"
      dependencies: ["ext_mention"]
    }

    # Rule 4: Wikipedia redirect (does the entity have a Wiki redirect with the same text as the mention?)
    wiki_redirect {
      sql: """
          DROP TABLE IF EXISTS el_wiki_redirect CASCADE;

          CREATE TABLE el_wiki_redirect AS
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   entity_feature_wikiredirect AS "w"
              WHERE e.fid = w.eid1 AND
                    m.word = w.featurevalue2;
        """
      style: "sql_extractor"
      dependencies: ["ext_mention"]
    }

    # Rule 5: Top Bing result (if the top Bing result for the mention is the entity)
    top_search_engine_result {
      sql: """
          DROP TABLE IF EXISTS el_top_search_engine_result CASCADE;

          CREATE TABLE el_top_search_engine_result AS
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   entity_feature_bing_query AS "q",
                   el_kbp_eval_query AS "eval"
              WHERE e.fid = q.eid2 AND
                    q.query1 = m.word AND
                    m.word = eval.text AND
                    m.doc_id = eval.doc_id AND
                    q.rank3 = '1';
        """
      style: "sql_extractor"
      dependencies: ["ext_mention"]
    }

    # Rule 6: Search engine result (if the entity comes up as a search engine result for the mention)
    search_engine_result {
      sql: """
          DROP TABLE IF EXISTS el_search_engine_result CASCADE;

          CREATE TABLE el_search_engine_result AS
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   entity_feature_bing_query AS "q",
                   el_kbp_eval_query AS "eval"
              WHERE e.fid = q.eid2 AND
                    q.query1 = m.word AND
                    m.word = eval.text AND
                    m.doc_id = eval.doc_id AND
                    q.rank3 IS NOT NULL;
        """
      style: "sql_extractor"
      dependencies: ["ext_mention"]
    }

    # Rule 7: exact string match on the freebase alias (PERSON).
    # Choose pairs of PERSON mentions and entities where the mention string contains a space and
    # the freebase alias for the entity is an exact string match for the mention text.
    fbalias_person {
      sql: """
          DROP TABLE IF EXISTS el_fbalias CASCADE;

          CREATE TABLE el_fbalias AS
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   fbalias AS "f"
              WHERE m.type = 'PERSON' AND
                    e.type = 'people.person' AND
                    m.word = f.slot AND
                    e.fid = f.fid AND
                    m.word LIKE '% %';
        """
      style: "sql_extractor"
      dependencies: ["ext_mention"]
    }

    # Rule 7: exact string match on the freebase alias (ORGANIZATION).
    # Choose pairs of ORGANIZATION mentions and entities where
    # the freebase alias for the entity is an exact string match for the mention text.
    fbalias_organization {
      sql: """
          INSERT INTO el_fbalias
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   fbalias AS "f"
              WHERE m.type = 'ORGANIZATION' AND
                    e.type = 'organization.organization' AND
                    m.word = f.slot AND
                    e.fid = f.fid;
        """
      style: "sql_extractor"
      dependencies: ["fbalias_person"]
    }

    # Rule 7: exact string match on the freebase alias (LOCATION).
    # Choose pairs of LOCATION mentions and entities where
    # the freebase alias for the entity is an exact string match for the mention text.
    fbalias_location {
      sql: """
          INSERT INTO el_fbalias
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   fbalias AS "f"
              WHERE m.type = 'LOCATION' AND
                    e.type = 'location.location' AND
                    m.word = f.slot AND
                    e.fid = f.fid;
        """
      style: "sql_extractor"
      dependencies: ["fbalias_person"]
    }

    # Rule 7: exact string match on the freebase alias (TITLE).
    # Choose pairs of TITLE mentions and entities where
    # the freebase alias for the entity is an exact string match for the mention text.
    fbalias_title {
      sql: """
          INSERT INTO el_fbalias
            SELECT DISTINCT
                  m.doc_id AS "doc_id",
                  m.mention_id AS "mention_id",
                  e.fid AS "entity_id"
              FROM mentions AS "m",
                   entities AS "e",
                   fbalias AS "f"
              WHERE m.type = 'TITLE' AND
                    e.type = 'business.job_title' AND
                    m.word = f.slot AND
                    e.fid = f.fid;
        """
      style: "sql_extractor"
      dependencies: ["fbalias_person"]
    }


    # Combine all of the rules into el_candidate_link
    el_round_1 {
      cmd: ${APP_HOME}"/udf/scripts/el_round1.sh"
      style: "cmd_extractor"
      dependencies: ["everything_nil", "exact_str_match", "wiki_link", "wiki_redirect",
                     "top_search_engine_result", "search_engine_result", "fbalias_person", "fbalias_location",
                     "fbalias_organization", "fbalias_title"]
    }



    ## ROUND 2 OF FEATURES

    # Rule 9: promote entity-mention links with consistent types

    # Person
    consistent_types_person {
      sql: """
          DROP TABLE IF EXISTS el_consistent_types;

          CREATE TABLE el_consistent_types AS
            SELECT DISTINCT
                  link.doc_id AS "doc_id",
                  link.mention_id AS "mention_id",
                  link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   mentions AS "m",
                   entities AS "e"
              WHERE link.doc_id = m.doc_id AND
                    link.entity_id = e.fid AND
                    link.mention_id = m.mention_id AND
                    m.type = 'PERSON' AND
                    e.type = 'people.person';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Location
    consistent_types_location {
      sql: """
          INSERT INTO el_consistent_types
            SELECT DISTINCT
                  link.doc_id AS "doc_id",
                  link.mention_id AS "mention_id",
                  link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   mentions AS "m",
                   entities AS "e"
              WHERE link.doc_id = m.doc_id AND
                    link.entity_id = e.fid AND
                    link.mention_id = m.mention_id AND
                    m.type = 'LOCATION' AND
                    e.type = 'location.location';
        """
      style: "sql_extractor"
      dependencies: ["consistent_types_person"]
    }

    # Organization
    consistent_types_organization {
      sql: """
          INSERT INTO el_consistent_types
            SELECT DISTINCT
                  link.doc_id AS "doc_id",
                  link.mention_id AS "mention_id",
                  link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   mentions AS "m",
                   entities AS "e"
              WHERE link.doc_id = m.doc_id AND
                    link.entity_id = e.fid AND
                    link.mention_id = m.mention_id AND
                    m.type = 'ORGANIZATION' AND
                    e.type = 'organization.organization';
        """
      style: "sql_extractor"
      dependencies: ["consistent_types_location"]
    }

    # Title
    consistent_types_title {
      sql: """
          INSERT INTO el_consistent_types
            SELECT DISTINCT
                  link.doc_id AS "doc_id",
                  link.mention_id AS "mention_id",
                  link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   mentions AS "m",
                   entities AS "e"
              WHERE link.doc_id = m.doc_id AND
                    link.entity_id = e.fid AND
                    link.mention_id = m.mention_id AND
                    m.type = 'TITLE' AND
                    e.type = 'business.job_title';
        """
      style: "sql_extractor"
      dependencies: ["consistent_types_organization"]
    }

    consistent_types_title2 {
      sql: """
          INSERT INTO el_consistent_types
            SELECT DISTINCT
                  link.doc_id AS "doc_id",
                  link.mention_id AS "mention_id",
                  link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   mentions AS "m",
                   entities AS "e"
              WHERE link.doc_id = m.doc_id AND
                    link.entity_id = e.fid AND
                    link.mention_id = m.mention_id AND
                    m.type = 'TITLE' AND
                    e.type = 'government.government_office_or_title';
        """
      style: "sql_extractor"
      dependencies: ["consistent_types_organization"]
    }

    # Rule 10: Break ties using the more popular entity, but only if the other
    # entity is the most popular (80 means most popular)
    entity_popularity {
      sql: """
          DROP TABLE IF EXISTS el_entity_popularity;

          CREATE TABLE el_entity_popularity AS
            SELECT DISTINCT
                 link1.doc_id AS "doc_id",
                 link1.mention_id AS "mention_id",
                 link1.entity_id AS "entity_id" 
            FROM el_candidate_link AS "link1",
                 el_candidate_link AS "link2",
                 entities AS "e1",
                 entities AS "e2",
                 entity_feature_popularity AS "pop1",
                 entity_feature_popularity AS "pop2"
            WHERE link1.entity_id = e1.fid AND
                  link2.entity_id = e2.fid AND
                  link1.mention_id = link2.mention_id AND
                  e1.fid <> e2.fid AND
                  e1.fid = pop1.eid1 AND
                  e2.fid = pop2.eid1 AND
                  pop1.featurevalue2 = '80' AND
                  pop2.featurevalue2 <> '80';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 11: never believe that a single first/last name can provide useful info
    dont_trust_single_name {
      sql: """
          DROP TABLE IF EXISTS el_dont_trust_single_name;

          CREATE TABLE el_dont_trust_single_name AS
            SELECT DISTINCT
                 link.doc_id AS "doc_id",
                 link.mention_id AS "mention_id",
                 e_nil.fid AS "entity_id" 
            FROM el_candidate_link AS "link",
                 entities AS "e",
                 mentions AS "m",
                 mention_feature_text_num_words AS "num_words",
                 entities AS "e_nil"
            WHERE link.doc_id = m.doc_id AND
                  link.mention_id = m.mention_id AND
                  link.entity_id = e.fid AND
                  m.mention_id = num_words.mid AND
                  m.type = 'PERSON' AND
                  num_words.feature = '1' AND
                  e.fid <> 'NIL0000' AND
                  e_nil.fid = 'NIL0000';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1", "mention_text_num_words"]
    }

    # Rule 12: Context rule. Intuitively, if Wisconsin co-occurs with Madison, then promote
    # the entity ''Madison, WI''
    context {
      sql: """
          DROP TABLE IF EXISTS el_context CASCADE;

          CREATE TABLE el_context AS
            SELECT DISTINCT
                 link.doc_id AS "doc_id",
                 link.mention_id AS "mention_id",
                 link.entity_id AS "entity_id" 
            FROM el_candidate_link AS "link",
                 entity_feature_need_nodup AS "need",
                 mentions AS "m",
                 mentions AS "m1",
                 entities AS "e"
            WHERE link.doc_id = m.doc_id AND
                  link.mention_id = m.mention_id AND
                  link.entity_id = e.fid AND
                  need.eid1 = e.fid AND
                  need.word2 = m1.word AND
                  m.doc_id = m1.doc_id AND
                  m.sentence_id <> m1.sentence_id;
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 13: Location words are ambiguous (city/town)
    city_town_ambiguous {
      sql: """
          DROP TABLE IF EXISTS el_city_town_ambiguous CASCADE;

          CREATE TABLE el_city_town_ambiguous AS
            SELECT DISTINCT
                   m.doc_id AS "doc_id",
                   m.mention_id AS "mention_id",
                   e_nil.fid AS "entity_id"
              FROM el_kbp_eval_query,
                   usstate,
                   entity_feature_wikidisambiguation AS "d",
                   entities AS "e",
                   entities AS "e_nil",
                   mentions AS "m",
                   entity_feature_hasneed AS "hasneed",
                   freebase
              WHERE el_kbp_eval_query.text = usstate.word1 AND
                    m.word = el_kbp_eval_query.text AND
                    m.doc_id = el_kbp_eval_query.doc_id AND
                    d.eid1 = e.fid AND
                    d.featurevalue2 = usstate.word1 AND
                    e.fid = hasneed.eid1 AND
                    e_nil.fid = 'NIL0000' AND
                    freebase.type = 'type.type.instance' AND
                    freebase.fid = 'location.citytown' AND
                    freebase.slot = e.fid;
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 14: Location words are ambiguous (state)
    state_ambiguous {
      sql: """
          DROP TABLE IF EXISTS el_state_ambiguous CASCADE;

          CREATE TABLE el_state_ambiguous AS
            SELECT DISTINCT
                   m.doc_id AS "doc_id",
                   m.mention_id AS "mention_id",
                   e_nil.fid AS "entity_id"
              FROM el_kbp_eval_query,
                   ambcode,
                   mentions AS "m",
                   entities AS "e_nil"
              WHERE e_nil.fid = 'NIL0000' AND
                    el_kbp_eval_query.text = m.word AND
                    el_kbp_eval_query.doc_id = m.doc_id AND 
                    ambcode.lower = el_kbp_eval_query.text;
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 15: Impossible to involve an /internet/social_network_user in TAC KBP
    no_social_network_user {
      sql: """
          DROP TABLE IF EXISTS el_no_social_network_user CASCADE;

          CREATE TABLE el_no_social_network_user AS
            SELECT DISTINCT
                   link.doc_id AS "doc_id",
                   link.mention_id AS "mention_id",
                   link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   freebase AS "f"
              WHERE link.entity_id = f.slot AND
                    f.type = 'type.type.instance' AND
                    f.fid = 'internet.social_network_user';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 16: Impossible to involve a /time/event in TAC KBP
    no_time_event {
      sql: """
          DROP TABLE IF EXISTS el_no_time_event CASCADE;

          CREATE TABLE el_no_time_event AS
            SELECT DISTINCT
                   link.doc_id AS "doc_id",
                   link.mention_id AS "mention_id",
                   link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   freebase AS "f"
              WHERE link.entity_id = f.slot AND
                    f.type = 'type.type.instance' AND
                    f.fid = 'time.event';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 17: Impossible to involve a /people/family_name in TAC KBP
    no_family_name {
      sql: """
          DROP TABLE IF EXISTS el_no_family_name CASCADE;

          CREATE TABLE el_no_family_name AS
            SELECT DISTINCT
                   link.doc_id AS "doc_id",
                   link.mention_id AS "mention_id",
                   link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   freebase AS "f"
              WHERE link.entity_id = f.slot AND
                    f.type = 'type.type.instance' AND
                    f.fid = 'people.family_name';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 18: Impossible to involve a /base/givennames/given_name in TAC KBP
    no_given_name {
      sql: """
          DROP TABLE IF EXISTS el_no_given_name CASCADE;

          CREATE TABLE el_no_given_name AS
            SELECT DISTINCT
                   link.doc_id AS "doc_id",
                   link.mention_id AS "mention_id",
                   link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   freebase AS "f"
              WHERE link.entity_id = f.slot AND
                    f.type = 'type.type.instance' AND
                    f.fid = 'base.givennames.given_name';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }

    # Rule 19: Impossible to involve a /base/wfilmbase/film in TAC KBP
    no_film {
      sql: """
          DROP TABLE IF EXISTS el_no_film CASCADE;

          CREATE TABLE el_no_film AS
            SELECT DISTINCT
                   link.doc_id AS "doc_id",
                   link.mention_id AS "mention_id",
                   link.entity_id AS "entity_id"
              FROM el_candidate_link AS "link",
                   freebase AS "f"
              WHERE link.entity_id = f.slot AND
                    f.type = 'type.type.instance' AND
                    f.fid = 'base.wfilmbase.film';
        """
      style: "sql_extractor"
      dependencies: ["el_round_1"]
    }


    # Combine all of the rules from round 2 into el_candidate_link_2
    el_round_2 {
      cmd: ${APP_HOME}"/udf/scripts/el_round2.sh"
      style: "cmd_extractor"
      dependencies: ["el_round_1", "consistent_types_person",
                     "consistent_types_location", "consistent_types_organization",
                     "consistent_types_title", "consistent_types_title2", "entity_popularity",
                     "dont_trust_single_name", "context", "city_town_ambiguous", "state_ambiguous",
                     "no_social_network_user", "no_time_event", "no_family_name", "no_given_name",
                     "no_film"]
    }






    #
    # Training data
    #

    # Positive examples for relation mentions. These are taken from the table kb, which
    # contains tuples of the form (entity1, relation, entity2).
    ext_relation_mention_positive {
      sql: """
        INSERT INTO relation_mentions (doc_id, mid1, mid2, word1, word2, rel, is_correct)
          SELECT DISTINCT r.doc_id,
                          r.mid1,
                          r.mid2,
                          r.word1,
                          r.word2,
                          kb.rel,
                          True
          FROM relation_mention_features r,
               el_candidate_link_2 t1,
               el_candidate_link_2 t2,
               kb
          WHERE r.mid1 = t1.mention_id AND
                r.mid2 = t2.mention_id AND
                t1.entity_id = kb.eid1 AND
                t2.entity_id = kb.eid2 AND
                r.doc_id = t1.doc_id AND
                r.doc_id = t2.doc_id;
      """
      style: "sql_extractor"
      dependencies : ["el_round_2"]
      # dependencies : ["ext_el_feature_coref", "ext_el_feature_extstr_title", 
      #                 "ext_el_feature_extstr_organization", "ext_el_feature_extstr_location",
      #                 "ext_el_feature_extstr_person", "ext_coref_candidate", "ext_coref_candidate",
      #                 "ext_relation_mention_feature", "ext_relation_mention_feature_deppath", 
      #                 "ext_mention", "ext_el_feature_alias_person",
      #                 "ext_el_feature_alias_title", "ext_el_feature_alias_location",
      #                 "ext_el_feature_alias_organization"]
    }

    # Negative examples for relation mentions using a table of incompatible relations. For a given
    # positive example (entity1, relation1, entity2), a negative example would be
    # (entity1, relation2, entity2) where relation2 is incompatible with relation1.
    ext_relation_mention_negative {
      sql: """
        INSERT INTO relation_mentions (doc_id, mid1, mid2, word1, word2, rel, is_correct)
          SELECT DISTINCT t0.doc_id,
                          t0.mid1,
                          t0.mid2,
                          t0.word1,
                          t0.word2,
                          t1.type2,
                          False
          FROM relation_mentions t0,
               incompatible_relations t1
          WHERE t0.rel = t1.type1 AND
                t0.is_correct = True AND
                t0.rel <> t1.type2;
      """
      style: "sql_extractor"
      dependencies : ["ext_relation_mention_positive"]
    }

    #
    # Relation mentions
    #

    # Populate the relation mention table with non-example tuples; since we already extracted
    # features for relation mentions, simply use that table to get the relation mentions.
    ext_relation_mention {
      sql: """
        INSERT INTO relation_mentions (doc_id, mid1, mid2, word1, word2, rel, is_correct)
          SELECT DISTINCT t1.doc_id,
                          t1.mid1,
                          t1.mid2,
                          t1.word1,
                          t1.word2,
                          t0.rel,
                          NULL::boolean
          FROM relation_types t0,
               relation_mention_features t1
          WHERE t0.type1 = t1.type1 AND
                t0.type2 = t1.type2;
      """
      style: "sql_extractor"
      dependencies : ["ext_relation_mention_positive", "ext_relation_mention_negative"]
    }




    #
    # Relation instances
    #

    ext_relation_instance_candidates {
      sql: """
        DROP TABLE IF EXISTS relation_instances CASCADE;

        CREATE TABLE relation_instances AS
                 SELECT  DISTINCT
                         subj_link.entity_id      AS subject_id,
                         obj_link.entity_id       AS object_id,
                         mentions.rel              AS rel,
                         null::boolean            AS is_correct,
                         null::bigint             AS id
                    FROM relation_mentions mentions,
                         el_candidate_link_2 subj_link,
                         el_candidate_link_2 obj_link
                   WHERE subj_link.doc_id = mentions.doc_id AND
                         obj_link.doc_id = mentions.doc_id AND
                         subj_link.mention_id = mentions.mid1  AND
                         obj_link.mention_id  = mentions.mid2 AND
                         obj_link.entity_id <> 'NIL0000' AND
                         subj_link.entity_id <> 'NIL0000';
      """
      style: "sql_extractor"
      dependencies: ["el_round1", "ext_relation_mention", "ext_relation_mention_feature_wordseq",
                     "ext_relation_mention_feature_deppath"]
    }

  }

  ###
  ### INFERENCE RULES
  ###

  inference.factors: {

    #### ENTITY LINKING

    ####### RULES FOR ROUND 1

    # Rule 1: everything starts off as NIL
    rule_everything_nil {
      input_query: """
          SELECT link.doc_id AS "distribute.key",
                 link.is_correct AS "el_candidate_link.is_correct",
                 link.id AS "el_candidate_link.id"
            FROM el_candidate_link link,
                 el_everything_nil e
            WHERE link.entity_id = e.entity_id AND
                  link.mention_id = e.mention_id AND
                  link.doc_id = e.doc_id
        """
      function: "IsTrue(el_candidate_link.is_correct)"
      weight: 2.8
    }

    # Rule 2: exact string match
    rule_exact_str_match {
      input_query: """
          SELECT link.doc_id AS "distribute.key",
                 link.is_correct AS "el_candidate_link.is_correct",
                 link.id AS "el_candidate_link.id"
            FROM el_candidate_link link,
                 el_exact_str_match e
            WHERE link.entity_id = e.entity_id AND
                  link.mention_id = e.mention_id AND
                  link.doc_id = e.doc_id
        """
      function: "IsTrue(el_candidate_link.is_correct)"
      weight: 2
    }

    # Rule 3: Wikipedia link (does the entity have a Wiki link with the same text as the mention?)
    rule_wiki_link {
      input_query: """
          SELECT link.doc_id AS "distribute.key",
                 link.is_correct AS "el_candidate_link.is_correct",
                 link.id AS "el_candidate_link.id"
            FROM el_candidate_link link,
                 el_wiki_link e
            WHERE link.entity_id = e.entity_id AND
                  link.mention_id = e.mention_id AND
                  link.doc_id = e.doc_id
        """
      function: "IsTrue(el_candidate_link.is_correct)"
      weight: 2
    }

    # Rule 4: Wikipedia redirect (does the entity have a Wiki redirect with the same text as the mention?)
    rule_wiki_redirect {
      input_query: """
          SELECT link.doc_id AS "distribute.key",
                 link.is_correct AS "el_candidate_link.is_correct",
                 link.id AS "el_candidate_link.id"
            FROM el_candidate_link link,
                 el_wiki_redirect e
            WHERE link.entity_id = e.entity_id AND
                  link.mention_id = e.mention_id AND
                  link.doc_id = e.doc_id
        """
      function: "IsTrue(el_candidate_link.is_correct)"
      weight: 2
    }

    # Rule 5: Top Bing result (if the top Bing result for the mention is the entity)
    rule_top_search_engine_result {
      input_query: """
          SELECT link.doc_id AS "distribute.key",
                 link.is_correct AS "el_candidate_link.is_correct",
                 link.id AS "el_candidate_link.id"
            FROM el_candidate_link link,
                 el_top_search_engine_result e
            WHERE link.entity_id = e.entity_id AND
                  link.mention_id = e.mention_id AND
                  link.doc_id = e.doc_id
        """
      function: "IsTrue(el_candidate_link.is_correct)"
      weight: 1
    }

    # Rule 6: Bing result (if the entity is a Bing result for the mention)
    rule_search_engine_result {
      input_query: """
          SELECT link.doc_id AS "distribute.key",
                 link.is_correct AS "el_candidate_link.is_correct",
                 link.id AS "el_candidate_link.id"
            FROM el_candidate_link link,
                 el_search_engine_result e
            WHERE link.entity_id = e.entity_id AND
                  link.mention_id = e.mention_id AND
                  link.doc_id = e.doc_id
        """
      function: "IsTrue(el_candidate_link.is_correct)"
      weight: 2
    }

    # Rule 7: exact string match on the freebase alias
    rule_fbalias {
      input_query: """
          SELECT link.doc_id AS "distribute.key",
                 link.is_correct AS "el_candidate_link.is_correct",
                 link.id AS "el_candidate_link.id"
            FROM el_candidate_link link,
                 el_fbalias e
            WHERE link.entity_id = e.entity_id AND
                  link.mention_id = e.mention_id AND
                  link.doc_id = e.doc_id
        """
      function: "IsTrue(el_candidate_link.is_correct)"
      weight: 2
    }


    ####### RULES FOR ROUND 2

    # Rule 8: believe everything in the first round
    rule_believe_first_round {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, el_candidate_link_2.is_correct)"
      weight: 2
    }

    # Rule 9: promote e-m links with consistent types
    rule_consistent_types {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_candidate_link_2 link2,
                 el_consistent_types link1_t
            WHERE link1.entity_id = link1_t.entity_id AND
                  link1.mention_id = link1_t.mention_id AND
                  link2.mention_id = link1.mention_id AND
                  link2.entity_id = link1.entity_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_t.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, el_candidate_link_2.is_correct)"
      weight: 4
    }

    # Rule 10: if the link in round 1 involves a popular entity
    rule_entity_popularity {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_entity_popularity link1_p,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_p.entity_id AND
                  link1.mention_id = link1_p.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_p.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, el_candidate_link_2.is_correct)"
      weight: 0.2
    }

    # Rule 11: never believe that a single first/last name can provide useful info
    rule_dont_trust_single_name {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_candidate_link_2 link2,
                 el_dont_trust_single_name link1_n
            WHERE link1.entity_id = link1_n.entity_id AND
                  link1.mention_id = link1_n.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link1_n.doc_id AND
                  link1.doc_id = link2.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, el_candidate_link_2.is_correct)"
      weight: 3
    }

    # Rule 12: Context rule. Intuitively, if Wisconsin co-occurs with Madison, then promote
    # the entity ''Madison, WI''
    rule_context {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_candidate_link_2 link2,
                 el_context link1_c
            WHERE link1.entity_id = link1_c.entity_id AND
                  link1.mention_id = link1_c.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_c.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, el_candidate_link_2.is_correct)"
      weight: 2
    }

    # Rule 13: Location words are ambiguous (city/town)
    rule_city_town_ambiguous {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_city_town_ambiguous link1_a,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_a.entity_id AND
                  link1.mention_id = link1_a.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_a.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, el_candidate_link_2.is_correct)"
      weight: 10
    }

    # Rule 14: Location words are ambiguous (state)
    rule_state_ambiguous {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_state_ambiguous link1_a,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_a.entity_id AND
                  link1.mention_id = link1_a.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_a.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, el_candidate_link_2.is_correct)"
      weight: 2
    }

    # Rule 15: Impossible to involve an /internet/social_network_user in TAC KBP
    rule_no_social_network_user {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_no_social_network_user link1_a,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_a.entity_id AND
                  link1.mention_id = link1_a.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_a.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, !el_candidate_link_2.is_correct)"
      weight: 10
    }

    # Rule 16: Impossible to involve a /time/event in TAC KBP
    rule_no_time_event {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_no_time_event link1_a,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_a.entity_id AND
                  link1.mention_id = link1_a.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_a.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, !el_candidate_link_2.is_correct)"
      weight: 10
    }

    # Rule 17: Impossible to involve a /people/family_name in TAC KBP
    rule_no_family_name {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_no_family_name link1_a,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_a.entity_id AND
                  link1.mention_id = link1_a.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_a.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, !el_candidate_link_2.is_correct)"
      weight: 2
    }

    # Rule 18: Impossible to involve a /base/givennames/given_name in TAC KBP
    rule_no_given_name {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_no_given_name link1_a,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_a.entity_id AND
                  link1.mention_id = link1_a.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link1_a.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, !el_candidate_link_2.is_correct)"
      weight: 10
    }

    # Rule 19: Impossible to involve a /base/wfilmbase/film in TAC KBP
    rule_no_film {
      input_query: """
          SELECT link1.doc_id AS "distribute.key",
                 link1.is_correct AS "el_candidate_link.is_correct",
                 link1.id AS "el_candidate_link.id",
                 link2.is_correct AS "el_candidate_link_2.is_correct",
                 link2.id AS "el_candidate_link_2.id"
            FROM el_candidate_link link1,
                 el_no_film link1_a,
                 el_candidate_link_2 link2
            WHERE link1.entity_id = link1_a.entity_id AND
                  link1.mention_id = link1_a.mention_id AND
                  link1.entity_id = link2.entity_id AND
                  link1.mention_id = link2.mention_id AND
                  link1.doc_id = link2.doc_id AND
                  link1.doc_id = link1_a.doc_id
        """
      function: "Imply(el_candidate_link.is_correct, !el_candidate_link_2.is_correct)"
      weight: 10
    }


    #### SLOT FILLING


    #### MENTION-LEVEL RELATIONS

    # Learn the expectation for the is_correct column of relation_mentions using the
    # features for a given relation mention. The system will learn a weight for each feature using
    # the positive and negative examples.
    relation_mention_lr {
      input_query: """
        SELECT t0.doc_id AS "distribute.key",
               t0.id AS "relation_mentions.id",
               t0.is_correct AS "relation_mentions.is_correct",
               t0.rel || '_' || t1.feature AS "feature"
        FROM relation_mentions t0,
             relation_mention_features t1
        WHERE t0.doc_id = t1.doc_id AND
              t0.mid1 = t1.mid1 AND
              t0.mid2 = t1.mid2;
      """
      function: "IsTrue(relation_mentions.is_correct)"
      weight: "?(feature)"
    }


    ### INSTANCE-LEVEL RELATIONS

    # Gather relation mentions into relation instances
    relation_instancess {
      input_query: """
        SELECT
            instance.subject_id AS "distribute.key",
            instance.id AS "relation_instances.id",
            instance.is_correct AS "relation_instances.is_correct",
            mention.id AS "relation_mentions.id",
            mention.is_correct AS "relation_mentions.is_correct",
            subj_link.id AS "el_candidate_link.subj.id",
            subj_link.is_correct AS "el_candidate_link_2.subj.is_correct",
            obj_link.id AS "el_candidate_link.obj.id",
            obj_link.is_correct AS "el_candidate_link_2.obj.is_correct"
        FROM relation_instances instance,
             relation_mentions mention,
             el_candidate_link_2 subj_link,
             el_candidate_link_2 obj_link
        WHERE subj_link.doc_id = obj_link.doc_id AND
              mention.doc_id = subj_link.doc_id AND
              subj_link.entity_id  = instance.subject_id AND
              subj_link.mention_id = mention.mid1  AND
              obj_link.entity_id   = instance.object_id  AND
              obj_link.mention_id  = mention.mid2   AND
              mention.rel = instance.rel AND
              obj_link.entity_id <> 'NIL0000' AND
              subj_link.entity_id <> 'NIL0000';
        """
      function: "Imply(relation_mentions.is_correct, el_candidate_link_2.subj.is_correct, el_candidate_link_2.obj.is_correct, relation_instances.is_correct)"
      weight: "?"
    }

  }

}
