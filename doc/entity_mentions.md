---
layout: default
---

Entity mentions
====

We first need to identify the entity mentions in the text. Given a set of sentences, the entity mention extractor will populate the `mentions` table using NER tags from the `sentence` table, generated by the NLP toolkit.

This extractor is defined in `application.conf` using the following code:

```bash
ext_mention {
  input : """
    SELECT doc_id,
           sentence_id,
           my_array_to_string(words, '~^~', 'NULL') AS words,
           my_array_to_string(ner, '~^~', 'NULL') AS ner,
           my_array_to_string(character_offset_begin, '~^~', 'NULL') AS character_offset_begin,
           my_array_to_string(character_offset_end, '~^~', 'NULL') AS character_offset_end
    FROM sentence
  """
  output_relation: "mentions"
  udf: ${APP_HOME}"/udf/ext_mention.py"
  style: "tsv_extractor"
  dependencies : ["ext_cleanup"]
}
```

Note that `my_array_to_string` is a function defined in `schema.sql` and is a simple modification of the default PSQL `array_to_string` function: in addition to the array and delimiter arguments, the function also accepts a string with which NULL values in the array will be replaced. Here we wish to replace the NULL elements in the arrays with the word 'NULL'.

The input query simply selects the appropriate columns from the sentence table and converts to strings the columns that contain arrays (since TSV extractors take in strings as input).

**Input:** sentences along with NER tags. Specically, each line in the input to this extractor UDF is a row in the `sentence` table in TSV format, e.g.:

    AFP_ENG_20070405.0102.LDC2009T13    AFP_ENG_20070405.0102.LDC2009T13_55 Larijani~^~,~^~head~^~of~^~Iran~^~'s~^~supreme~^~national~^~security~^~council~^~,~^~is~^~a~^~natural~^~conservative~^~but~^~his~^~moderate~^~and~^~distinctly~^~undramatic~^~language~^~contrasts~^~starkly~^~with~^~the~^~more~^~volatile~^~rhetoric~^~of~^~President~^~Mahmoud~^~Ahmadinejad~^~. PERSON~^~O~^~O~^~O~^~COUNTRY~^~O~^~ORGANIZATION~^~ORGANIZATION~^~ORGANIZATION~^~ORGANIZATION~^~O~^~O~^~O~^~O~^~IDEOLOGY~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~O~^~TITLE~^~PERSON~^~PERSON~^~O   497~^~505~^~507~^~512~^~515~^~519~^~522~^~530~^~539~^~548~^~555~^~557~^~560~^~562~^~570~^~583~^~587~^~591~^~600~^~604~^~615~^~626~^~635~^~645~^~653~^~658~^~662~^~667~^~676~^~685~^~688~^~698~^~706~^~717   505~^~506~^~511~^~514~^~519~^~521~^~529~^~538~^~547~^~555~^~556~^~559~^~561~^~569~^~582~^~586~^~590~^~599~^~603~^~614~^~625~^~634~^~644~^~652~^~657~^~661~^~666~^~675~^~684~^~687~^~697~^~705~^~717~^~718

**Output:** rows in `mentions` table, e.g.:

    AFP_ENG_20070405.0102.LDC2009T13    AFP_ENG_20070405.0102.LDC2009T13_497_505    AFP_ENG_20070405.0102.LDC2009T13_55 larijani    PERSON  0   1
    AFP_ENG_20070405.0102.LDC2009T13    AFP_ENG_20070405.0102.LDC2009T13_515_519    AFP_ENG_20070405.0102.LDC2009T13_55 iran    LOCATION    4   5
    AFP_ENG_20070405.0102.LDC2009T13    AFP_ENG_20070405.0102.LDC2009T13_522_555    AFP_ENG_20070405.0102.LDC2009T13_55 supreme national security council   ORGANIZATION    6   10
    ...

A mention can consist of multiple words (e.g. Barack Obama); the way we can identify these is if all of these words have the same NER tag. This extractor goes through all the words in the sentence and outputs as a mention the consecutive words that have the same NER tag.

The script `$APP_HOME/udf/ext_mention.py` is the UDF for this extractor:

```python
#! /usr/bin/env python

import sys

# the NER tags that wil not correspond to entity mentions types
EXT_MENTION_IGNORE_TYPE = {'URL': 1, 'NUMBER' : 1, 'MISC' : 1, 'CAUSE_OF_DEATH' : 1,
    'CRIMINAL_CHARGE' : 1, 'DURATION' : 1, 'MONEY' : 1, 'ORDINAL' : 1, 'RELIGION' : 1,
    'SET' : 1, 'TIME' : 1}

# words that are representative of the TITLE type
EXT_MENTION_TITLE_TYPE = {'winger' : 1, 'singer\\\\/songwriter' : 1, 'founder' : 1,
    'president' : 1, 'executive director' : 1, 'producer' : 1, 'star' : 1, 'musician' : 1,
    'nightlife impresario' : 1, 'lobbyist' : 1}

# the delimiter used to separate columns in the input
ARR_DELIM = '~^~'

for row in sys.stdin:
  # row is a string where the columns are separated by tabs
  (doc_id, sentence_id, words_str, ner_str, character_offset_begin_str, \
    character_offset_end_str) = row.strip().split('\t')

  words = words_str.split(ARR_DELIM)
  ner = ner_str.split(ARR_DELIM)
  character_offset_begin = map(lambda x: int(x), character_offset_begin_str.split(ARR_DELIM))
  character_offset_end = map(lambda x: int(x), character_offset_end_str.split(ARR_DELIM))

  # keep track of words whose NER tags we look at
  history = {}

  # go through each word in the sentence
  for i in range(0, len(words)):
    # if we already looked at this word's NER tag, skip it
    if i in history:
      continue

    # the NER tag for the current word
    curr_ner = ner[i]

    # skip this word if this NER tag should be ignored
    if curr_ner in EXT_MENTION_IGNORE_TYPE:
      continue

    # collapse specific location types
    if curr_ner in ["CITY", "COUNTRY", "STATE_OR_PROVINCE"]:
      curr_ner = "LOCATION"

    # if the current word has a valid NER tag
    if curr_ner != 'O' and curr_ner != 'NULL':
      j = i

      # go through each of the words after the current word until the end of the sentence
      for j in range(i, len(words)):
        nerj = ner[j]

        # collapse specific location types
        if nerj in ["CITY", "COUNTRY", "STATE_OR_PROVINCE"]:
          nerj = "LOCATION"

        # go until the NER tags of word 1 and word 2 do not match
        if nerj != curr_ner:
          break

      # at this point we have a mention that consists of consecutive words with the same NER 
      # tag (or just a single word if the next word's NER tag is different)

      # construct a unique ID for this entity mention
      mention_id = doc_id + "_%d_%d" % (character_offset_begin[i], character_offset_end[j-1])

      # if our mention is just a single word, we want just that word
      if i == j:
        j = i + 1
        word = words[i]
        history[i] = 1

      # if our mention is multiple words, combine them and mark that we have already seen them
      else:
        word = " ".join(words[i:j])
        for w in range(i,j):
          history[w] = 1

      # doc_id, mention_id, sentence_id, word, type, start_pos, end_pos
      output = [doc_id, mention_id, sentence_id, word.lower(), curr_ner, str(i), str(j)]

      # make sure each of the strings we will output is encoded as utf-8
      map(lambda x: x.decode('utf-8', 'ignore'), output)

      print "\t".join(output)
    
    # if this word has an NER tag of '0' or NULL
    else:
      # if the current word is one of the known titles, then we have a TITLE mention
      if words[i].lower() in EXT_MENTION_TITLE_TYPE:
        history[i] = 1
        word = words[i]
        
        # construct a unique ID for this entity mention
        mention_id = doc_id + "_%d_%d" % (character_offset_begin[i], character_offset_end[i])
        
        # doc_id, mention_id, sentence_id, word, type, start_pos, end_pos
        output = [doc_id, mention_id, str(sentence_id), word.lower(), 'TITLE', str(i), str(i + 1)]

        # make sure each of the strings we will output is encoded as utf-8
        map(lambda x: x.decode('utf-8', 'ignore'), output)

        print "\t".join(output)
```

The next step is to [extract features from mention-level relation candidates](extracting_mention_features.md).